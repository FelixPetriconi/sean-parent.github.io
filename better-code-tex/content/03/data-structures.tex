\section{What is an \textit{incidental} data structure?}

A typical definition for \textit{data structure} is:

\begin{itemize}
\item A \textit{data structure} is a format for organizing and storing data. \comment{citation?}
\end{itemize}

However, this definition doesn't define \textit{structure}, instead it replaces it with the related word, \textit{format}. In mathematics, \textit{structure} is defined as:

\begin{itemize}
\item A \textit{structure} on a set consists of additional entities that, in some manner, relate to the set, endowing the collection with meaning or significance. \comment{citation?}
\end{itemize}

\comment{Some of this section may move into chapter 1}

As we saw in [chapter 1](01-types.html) a type is a pattern for storing and modifying objects. That is, a type is a structure that relates a set of objects to a set of values. This is a \textit{representational} relationship and it is this relationship that imbues the type with meaning. A representational relationship creates a \textit{trivial data structure} consisting of a single value.

Values are related to other values, for example, 3 is not equal to 4.

If two objects of the same type have the same representation then they represent the same value. Representational equality implies value equality. If the representation is unique then the converse is also true. A hash is a regular function on a representation or a value. Because it is regular, if two values are equal then the hash of the values are also equal.

Because objects exist in memory, they have a \textit{physical} relationship. The value at the first location in an array is located before the value in the second location. If we sort the values, we establish a correspondence between the physical and value relationships, i.e. an element before another element is less than or equal to that element. We can represent locations as values (pointers) and use those to represent additional relationships, such as "is a child of".

Given this, an improved definition of a data structure is:

\begin{itemize}
\item A \textit{data structure} is a structure utilizing value, representational, and physical relationships to encode semantic relationships on a collection of objects.
\end{itemize}


The choice of encoding can make a dramatic difference on the performance of operations performed on the collection.

\comment{Digression into memory hierarchy performance and utilizing relationships with algorithms - where should that go }

Although data structures tend to be thought of simply in terms of containers such as arrays, lists, or maps, anytime a relationship is established between objects a data structure is created. However, to avoid confusion we will reserve the term \textit{data structure} to refer to types with a set of invariants which insure a set of relationships are maintained. More transient data structures will be referred to as \textit{structured data}.

As an example of utilizing \textit{structured data}, consider the problem of finding the `nth` to `mth` elements of an array as if the array was in sorted order. The trivial way to do this is to simply sort the entire array and then print the `nth` to `mth` elements. In this example $[sf, sl)$ is a subrange of $[f, l)$. \comment{appendix to describe half open notation?}

\begin{minipage}{\linewidth}
	\lstinputlisting[language=C++,
	                   %linebackgroundcolor={% }
	  ]{code/sort-subrange-0.cpp}
\end{minipage}

%{% include code.md name='sort-subrange-0' caption='inefficient sort subrange' %}

\comment{Should this section start with partial\_sort then add nth\_element instead of the other way around?}

This function, however, does more work than is necessary. 
There is a function in the standard library, \codeintext{nth_element()} which given a position $nth$ within a range $[f, l)$ has the post condition that the element at $nth$ is the same element that would be in that position if $[f, l)$ were sorted. \codeintext{nth_element()} is a special case of \codeintext{sort_subrange()} when the subrange is of length 1 (or 0 if $nth == l$).

This would not be of much use to build\codeintext{sort_subrange()}
except that \codeintext{nth_element()} has an additional post condition. The range $[f, l)$ is partitioned such that all elements prior to $nth$ are less than or equal to the final element at $nth$. This post condition leaves us with \textit{structured data} and we can take advantage of that structure. If we find the \codeintext{nth_element()} where $nth$ is $sf$ then we only need to sort the remaining elements to $sl$ which can be done with \codeintext{partial_sort()}.


\begin{minipage}{\linewidth}
	\lstinputlisting[language=C++,
	                   %linebackgroundcolor={% }
	  ]{code/sort-subrange-1.cpp}
\end{minipage}  
  
  
% include code.md name='sort-subrange-1' caption='improved sort subrange' %

We can improve this function slightly by noting that in the case where $sf == f$ we do not need to call \codeintext{nth_element()}.

\begin{minipage}{\linewidth}
	\lstinputlisting[language=C++,
	                   %linebackgroundcolor={% }
	  ]{code/sort-subrange-2.cpp}
\end{minipage}

\comment{add exercise to test performance?}

\subsection{Composite Objects and the Whole-Part relationship}

A \textit{composite object} is consists of other objects, called \textit{parts}. These parts are related to the \textit{composite object} via a \textit{whole-part} relationship.

\begin{itemize}
\item A \textit{whole-part} relationship is \textit{connected}, \textit{non-circular}, \textit{logically disjoint}, and \textit{owned}. \textit{Connected} means any part is reachable from the object's starting address. \textit{Non-circular} means that no part is a part of itself. \textit{Logically disjoint} means that if two objects share a subpart where modifications to the subpart affect the value of both objects, then one of the objects must be a subpart of the other. \textit{Owned} means that copying the object copies its parts, and destroying the object destroys its parts. \footnote{Alexander Stepanov \& Paul McJones. \textit{Elements of Programming} (Addison-Wesley, 2009), 12.1}
\end{itemize}
